diff --git a/apis/apps/v1alpha1/daemonset_types.go b/apis/apps/v1alpha1/daemonset_types.go
index aec3f7df..0fc45d6c 100644
--- a/apis/apps/v1alpha1/daemonset_types.go
+++ b/apis/apps/v1alpha1/daemonset_types.go
@@ -152,6 +152,9 @@ type DaemonSetSpec struct {
 	// The default value is 250
 	BurstReplicas *intstr.IntOrString `json:"burstReplicas,omitempty"`
 
+	// Replicas is the number of desired pods in accordance with the number matching nodes.
+	Replicas *int32 `json:"replicas,omitempty"`
+
 	// The number of old history to retain to allow rollback.
 	// This is a pointer to distinguish between explicit zero and not specified.
 	// Defaults to 10.
diff --git a/pkg/controller/daemonset/daemonset_controller.go b/pkg/controller/daemonset/daemonset_controller.go
index 1934f145..ab81b88d 100644
--- a/pkg/controller/daemonset/daemonset_controller.go
+++ b/pkg/controller/daemonset/daemonset_controller.go
@@ -505,7 +505,7 @@ func NewPod(ds *appsv1alpha1.DaemonSet, nodeName string) *corev1.Pod {
 	// newPod.Spec.NodeName = nodeName
 
 	// Added default tolerations for DaemonSet pods.
-	util.AddOrUpdateDaemonPodTolerations(&newPod.Spec)
+	// util.AddOrUpdateDaemonPodTolerations(&newPod.Spec)
 
 	newPodForDSCache.Store(ds.UID, &newPodForDS{generation: ds.Generation, pod: newPod})
 	return newPod
@@ -560,6 +560,11 @@ func (dsc *ReconcileDaemonSet) updateDaemonSetStatus(ds *appsv1alpha1.DaemonSet,
 		return fmt.Errorf("error storing status for DaemonSet %v: %v", ds.Name, err)
 	}
 
+	err = dsc.updateDaemonSetReplicas(ds, desiredNumberScheduled)
+	if err != nil {
+		return fmt.Errorf("error updating DaemonSet %v replicas: %v", ds.Name, err)
+	}
+
 	// Resync the DaemonSet after MinReadySeconds as a last line of defense to guard against clock-skew.
 	if ds.Spec.MinReadySeconds >= 0 && numberReady != numberAvailable {
 		durationStore.Push(keyFunc(ds), time.Duration(ds.Spec.MinReadySeconds)*time.Second)
@@ -567,6 +572,53 @@ func (dsc *ReconcileDaemonSet) updateDaemonSetStatus(ds *appsv1alpha1.DaemonSet,
 	return nil
 }
 
+func (dsc *ReconcileDaemonSet) getEligibleNodesCount(nodeSelector map[string]string) (int32, error) {
+	nodeCount, err := dsc.kubeClient.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{LabelSelector: labels.SelectorFromSet(nodeSelector).String()})
+	if err != nil {
+		return 0, err
+	}
+	return int32(len(nodeCount.Items)), nil
+}
+
+func (dsc *ReconcileDaemonSet) updateDaemonSetReplicas(ds *appsv1alpha1.DaemonSet, desiredNumberScheduled int) error {
+	var nodeCount int32
+	nodeCount, err := dsc.getEligibleNodesCount(ds.Spec.Template.Spec.NodeSelector)
+	if err != nil {
+		return err
+	}
+
+	if ds.Spec.Replicas != nil && *ds.Spec.Replicas == nodeCount {
+		return nil
+	}
+
+	dsClient := dsc.kruiseClient.AppsV1alpha1().DaemonSets(ds.Namespace)
+	toUpdate := ds.DeepCopy()
+	var updateErr, getErr error
+
+	return retry.RetryOnConflict(retry.DefaultBackoff, func() error {
+		toUpdate.Spec.Replicas = &nodeCount
+		if _, updateErr = dsClient.Update(context.TODO(), toUpdate, metav1.UpdateOptions{}); updateErr == nil {
+			klog.Infof("Updated DaemonSet %s/%s replicas to %d", ds.Namespace, ds.Name, nodeCount)
+			// if there are more nodes than Desired (cordoned and drained nodes)
+			// we need to resync DaemonSet after some time in case the cordoned/drained nodes get deleted
+			if nodeCount > int32(desiredNumberScheduled) {
+				durationStore.Push(keyFunc(ds), time.Duration(30)*time.Second)
+			}
+			return nil
+		}
+
+		klog.Errorf("Update DaemonSet replicas %v failed: %v", ds.Status, updateErr)
+		// Update the set with the latest resource version for the next poll
+		if toUpdate, getErr = dsClient.Get(context.TODO(), ds.Name, metav1.GetOptions{}); getErr != nil {
+			// If the GET fails we can't trust status.Replicas anymore. This error
+			// is bound to be more interesting than the update failure.
+			klog.Errorf("Get DaemonSet %v for replicas update failed: %v", ds.Name, getErr)
+			return getErr
+		}
+		return updateErr
+	})
+}
+
 func (dsc *ReconcileDaemonSet) storeDaemonSetStatus(ds *appsv1alpha1.DaemonSet, desiredNumberScheduled, currentNumberScheduled, numberMisscheduled, numberReady, updatedNumberScheduled, numberAvailable, numberUnavailable int, updateObservedGen bool, hash string) error {
 	if int(ds.Status.DesiredNumberScheduled) == desiredNumberScheduled &&
 		int(ds.Status.CurrentNumberScheduled) == currentNumberScheduled &&
