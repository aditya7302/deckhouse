diff --git a/apis/apps/v1alpha1/daemonset_types.go b/apis/apps/v1alpha1/daemonset_types.go
index aec3f7df..0fc45d6c 100644
--- a/apis/apps/v1alpha1/daemonset_types.go
+++ b/apis/apps/v1alpha1/daemonset_types.go
@@ -152,6 +152,9 @@ type DaemonSetSpec struct {
 	// The default value is 250
 	BurstReplicas *intstr.IntOrString `json:"burstReplicas,omitempty"`
 
+	// Replicas is the number of desired pods in accordance with the number matching nodes.
+	Replicas *int32 `json:"replicas,omitempty"`
+
 	// The number of old history to retain to allow rollback.
 	// This is a pointer to distinguish between explicit zero and not specified.
 	// Defaults to 10.
diff --git a/pkg/controller/daemonset/daemonset_controller.go b/pkg/controller/daemonset/daemonset_controller.go
index 1934f145..468ff884 100644
--- a/pkg/controller/daemonset/daemonset_controller.go
+++ b/pkg/controller/daemonset/daemonset_controller.go
@@ -505,7 +505,7 @@ func NewPod(ds *appsv1alpha1.DaemonSet, nodeName string) *corev1.Pod {
 	// newPod.Spec.NodeName = nodeName
 
 	// Added default tolerations for DaemonSet pods.
-	util.AddOrUpdateDaemonPodTolerations(&newPod.Spec)
+	// util.AddOrUpdateDaemonPodTolerations(&newPod.Spec)
 
 	newPodForDSCache.Store(ds.UID, &newPodForDS{generation: ds.Generation, pod: newPod})
 	return newPod
@@ -560,6 +560,11 @@ func (dsc *ReconcileDaemonSet) updateDaemonSetStatus(ds *appsv1alpha1.DaemonSet,
 		return fmt.Errorf("error storing status for DaemonSet %v: %v", ds.Name, err)
 	}
 
+	err = dsc.storeDaemonSetReplicas(ds)
+	if err != nil {
+		return fmt.Errorf("error updating DaemonSet %v replicas: %v", ds.Name, err)
+	}
+
 	// Resync the DaemonSet after MinReadySeconds as a last line of defense to guard against clock-skew.
 	if ds.Spec.MinReadySeconds >= 0 && numberReady != numberAvailable {
 		durationStore.Push(keyFunc(ds), time.Duration(ds.Spec.MinReadySeconds)*time.Second)
@@ -567,6 +572,33 @@ func (dsc *ReconcileDaemonSet) updateDaemonSetStatus(ds *appsv1alpha1.DaemonSet,
 	return nil
 }
 
+func (dsc *ReconcileDaemonSet) storeDaemonSetReplicas(ds *appsv1alpha1.DaemonSet) error {
+	if *ds.Spec.Replicas == ds.Status.DesiredNumberScheduled {
+		return nil
+	}
+	dsClient := dsc.kruiseClient.AppsV1alpha1().DaemonSets(ds.Namespace)
+	toUpdate := ds.DeepCopy()
+	var updateErr, getErr error
+
+	return retry.RetryOnConflict(retry.DefaultBackoff, func() error {
+		toUpdate.Spec.Replicas = &ds.Status.DesiredNumberScheduled
+		if _, updateErr = dsClient.Update(context.TODO(), toUpdate, metav1.UpdateOptions{}); updateErr == nil {
+			klog.Infof("Updated DaemonSet %s/%s replicas to %d", ds.Namespace, ds.Name, ds.Status.DesiredNumberScheduled)
+			return nil
+		}
+
+		klog.Errorf("Update DaemonSet replicas %v failed: %v", ds.Status, updateErr)
+		// Update the set with the latest resource version for the next poll
+		if toUpdate, getErr = dsClient.Get(context.TODO(), ds.Name, metav1.GetOptions{}); getErr != nil {
+			// If the GET fails we can't trust status.Replicas anymore. This error
+			// is bound to be more interesting than the update failure.
+			klog.Errorf("Get DaemonSet %v for replicas update failed: %v", ds.Name, getErr)
+			return getErr
+		}
+		return updateErr
+	})
+}
+
 func (dsc *ReconcileDaemonSet) storeDaemonSetStatus(ds *appsv1alpha1.DaemonSet, desiredNumberScheduled, currentNumberScheduled, numberMisscheduled, numberReady, updatedNumberScheduled, numberAvailable, numberUnavailable int, updateObservedGen bool, hash string) error {
 	if int(ds.Status.DesiredNumberScheduled) == desiredNumberScheduled &&
 		int(ds.Status.CurrentNumberScheduled) == currentNumberScheduled &&
